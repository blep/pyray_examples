"""raylib [textures] example - Load textures from raw data
Example complexity rating: [★★★☆] 3/4
NOTE: Images are loaded in CPU memory (RAM); textures are loaded in GPU memory (VRAM)
Example originally created with raylib 1.3, last time updated with raylib 3.5
Example licensed under an unmodified zlib/libpng license, which is an OSI-certified,
BSD-like license that allows static linking with closed source software
Copyright (c) 2015-2025 Ramon Santamaria (@raysan5)

This source has been converted from C raylib examples to Python.
"""

import pyray as rl
import ctypes
from pathlib import Path

THIS_DIR = Path(__file__).resolve().parent

# Initialization
screenWidth = 800
screenHeight = 450

rl.init_window(screenWidth, screenHeight, "raylib [textures] example - texture from raw data")

# NOTE: Textures MUST be loaded after Window initialization (OpenGL context is required)

# Load RAW image data (384x512, 32bit RGBA, no file header)
fudesumiRaw = rl.load_image_raw(str(THIS_DIR/"resources/fudesumi.raw"), 384, 512, 
                              rl.PIXELFORMAT_UNCOMPRESSED_R8G8B8A8, 0)
fudesumi = rl.load_texture_from_image(fudesumiRaw)  # Upload CPU (RAM) image to GPU (VRAM)
rl.unload_image(fudesumiRaw)                      # Unload CPU (RAM) image data

# Generate a checked texture by code
width = 960
height = 480

# Create a Color array and fill it with pattern
# We'll use pyray's ffi to create the array properly
pixels = rl.ffi.new("Color[%d]" % (width * height))

for y in range(height):
    for x in range(width):
        if (((x//32 + y//32)//1) % 2 == 0):
            pixels[y*width + x] = rl.ORANGE
        else:
            pixels[y*width + x] = rl.GOLD

# Create image using the pixel data
checkedIm = rl.Image()
checkedIm.data = rl.ffi.cast("void *", pixels)
checkedIm.width = width
checkedIm.height = height
checkedIm.format = rl.PIXELFORMAT_UNCOMPRESSED_R8G8B8A8
checkedIm.mipmaps = 1

checked = rl.load_texture_from_image(checkedIm)

# Note: We don't unload checkedIm here as it would free our pixels array
# which is managed by FFI. In a real application, you'd want to ensure
# proper memory management.

rl.set_target_fps(60)  # Set our game to run at 60 frames-per-second

# Main game loop
while not rl.window_should_close():  # Detect window close button or ESC key
    # Draw
    rl.begin_drawing()
    
    rl.clear_background(rl.RAYWHITE)
    
    rl.draw_texture(
        checked, 
        screenWidth//2 - checked.width//2, 
        screenHeight//2 - checked.height//2, 
        rl.fade(rl.WHITE, 0.5)
    )
    
    rl.draw_texture(fudesumi, 430, -30, rl.WHITE)
    
    rl.draw_text("CHECKED TEXTURE ", 84, 85, 30, rl.BROWN)
    rl.draw_text("GENERATED by CODE", 72, 148, 30, rl.BROWN)
    rl.draw_text("and RAW IMAGE LOADING", 46, 210, 30, rl.BROWN)
    
    rl.draw_text("(c) Fudesumi sprite by Eiden Marsal", 310, screenHeight - 20, 10, rl.BROWN)
    
    rl.end_drawing()

# De-Initialization
rl.unload_texture(fudesumi)  # Texture unloading
rl.unload_texture(checked)   # Texture unloading

rl.close_window()  # Close window and OpenGL context